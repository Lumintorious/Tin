Iterator = [T] => struct:
	next: () -> T?

Iterable = [T] => struct:
	makeIterator: () -> Iterator[T]

Accessible = [T] => struct:
	at: (index: Number) -> T?

VarAccessible = [T] => struct:
	at: (index: Number) -> T?
	place: (index: Number, value: T) -> Nothing

Growable = [K, V] => struct:
	add: (value: V) -> K
	remove: (value: V) -> K?
	removeAt: (key: K) -> V?

MapOps = [K, V] -> struct:
	get: (K) -> V?
	with: (K, V) -> Map[K, V]

Mergeable = [T, F: Mergeable] => struct:
	merge: (F[T]) -> F[T]

Map = [K, V] => MapOps[K, V] & Iterable[(K, V)]

external "
	function _arrToMap(K, V, arr) \{
		const symbol = _Q_share(Tuple2._s, [K._s, V._s])
		return new Map(arr[Array._s]._rawArray.map(tup => \{ return [tup[symbol].left._, tup[symbol].right._]\}))
	\}

	function _mapFromJsMap(K, V, jsMap) \{
		return ((MapOps(K, V)(\{_:function(k)\{ return jsMap.get(k)\}\}, \{_:function(k, v)\{
			const newJsMap = new Map(jsMap);
			newJsMap.set(k, v);
			return _mapFromJsMap(K, V, newJsMap);
		\}\}))._and(ToString(\{_:function() \{
			return `Map($\{[...jsMap].map(([k, v]) => `($\{makeStr(k)\},$\{makeStr(v)\})`).toString()\})`
		\}\})))._and(Iterable(Tuple2(K, V))(\{_:() => \{
			const entryArray = [...jsMap]
			let i = 0;

			return Iterator(Tuple2(K, V))(\{_:() => \{
				const entry = entryArray[i]
				i++;
				if (entry === undefined) return undefined;
				return Tuple2(K, V)(\{_:entry[0]\}, \{_:entry[1]\})
			\}\})
		\}\}))
	\}
	export const Map$of = (K, V) => (arr) => \{
		const jsMap = _arrToMap(K, V, arr)
		const map = _mapFromJsMap(K, V, jsMap)
		return map;
	\}
"

Map.of: [K, V] -> (kvs: Array[(K, V)]) -> Map[K, V] = external

Iterator.mapped = [T, X] -> (self: Iterator[T], fn: (T) -> X): Iterator[X] ->
	Iterator[X]((): X? ->
		prev = self.next()
		if prev !: Nothing,
			fn(prev)
		else
			nothing
	)

Iterable.into = [T, F] -> (self: Iterable[T], factory: (Iterable[T]) -> F[T]) ->
	factory(self)

Iterable.forEach = [T] -> (self: Iterable[T], fn: (T) -> Nothing) ->
	iterator = self.makeIterator()
	current = var iterator.next()
	
	while current !: Nothing,
		fn(current)
		set current = iterator.next()

Iterable.fromArray = [T] -> (arr: Array[T]) ->
	Iterable[T](() ->
		i = var -1
		Iterator[T](() ->
			set i = i + 1
			arr.at(i)
		)
	)

Iterable.fold = [T, S] -> (self: Iterable[T], start: S, combine: (T, S) -> S): S ->
	sum = var start
	self.forEach((e: T) ->
		set sum = combine(e, sum)
		nothing
	)

	sum

external "
export const Array$fromIterator = (T) => (iter) => \{
	const arr = [];
	let i = iter[Iterator._s].next._()
	while(i !== undefined && (typeof i === 'object' && i._ !== undefined)) \{
		arr.push(i)
		i = iter[Iterator._s].next._()
	\}
	return Array(T)(arr)

\}

"

Array.fromIterator: [T] -> (Iterator[T]) -> Array[T] = external
Array.fromIterable = [T] -> (iterable: Iterable[T]): Array[T] ->
	Array.fromIterator(iterable.makeIterator())

Array.stream = [T] -> (self: Array[T]) -> Iterable.fromArray(self)

# Json = Number | String | Array[Json] | Map[String, Json]

# Json.fromString: (string: String) -> Json | Error = external
# Json.toString: (json: Json) -> String = external

external "
export function Json$fromString(str) \{
	return JSON.parse(str, (key, value) => \{
		if (_JsArr.isArray(value)) return Array(Json)(value)
		if (typeof value === 'object') return _mapFromJsMap(String, Json, new Map(Object.entries(value)))

		return value;
	\})	
\}

export function Json$toString(js) \{
	function toJsRaw(obj) \{
		if (obj === undefined) return obj
		if (obj === null) return obj
		if (typeof obj === 'number') return obj
		if (typeof obj === 'string') return obj
		if (typeof obj === 'boolean') return obj

	\}

	function isMap(m) \{
		return typeof m === 'object' && Object.getOwnPropertySymbols(m).filter(o => o === MapOps._s).length > 0 && Object.getOwnPropertySymbols(m).filter(o => o === Iterable._s).length > 0;
	\}
	function isArray(m) \{
		return typeof m === 'object' && Object.getOwnPropertySymbols(m).filter(o => o === Array._s).length > 0;
	\}

	return JSON.stringify(js, (key, value) => \{
		if (isMap(value)) \{
			let obj = \{\}
			const iter = value[Iterable._s].makeIterator._()
			let i = iter[Iterator._s].next._();
			while (i !== undefined) \{
				obj[i[Tuple2._s].left._] = i[Tuple2._s].right._
				i = iter[Iterator._s].next._()
			\}
			return obj
		\}
		if (isArray(value)) \{
			return value[Array._s]._rawArray
		\}
		return value;
	\})	
\}
"

Iterable.toString = [T] -> (iter: Iterable[T], label: String = " "): String ->
	iterator = iter.makeIterator()
	current = var iterator.next()
	str = var "{label} \{"
	
	while current !: Nothing,
		set str = str + toString(current)
		set current = iterator.next()
		if current !: Nothing,
			set str = str + ", "

	str + " }"

Iterable.makeToString = [T] -> (iter: Iterable[T], label: String = " ") -> () -> Iterable.toString(iter, label)

Range = struct:
	start: Number
	end: Number
	step: Number

Range.from = (start: Number, end: Number, step: Number = 1) ->
	range = Range { start, end, step }
	iterable = Iterable[Number] { () ->
		link i = var start
		Iterator[Number] { () ->
			if i <= end,
				set i = i + step
				i - step
			else
				nothing
		}
	}
	range & iterable & Iterable.makeToString(iterable, "Range")
	 